import { GithubAuthStatus as GhAuthStatus, exec, githubAuthStatus, importChalk, importInquirer, readYamlFile, writeYamlFile } from "@cpdevtools/lib-node-utilities";
import { Octokit } from "@octokit/rest";
import { EndpointDefaults, Endpoints, OctokitResponse } from "@octokit/types";
import { differenceInHours, formatDistanceToNow, isValid, parseJSON } from "date-fns";
import { existsSync } from "fs";
import { mkdir, rm } from "fs/promises";
import { CachedFile } from "../cache";
import { DCM_CACHE_DIR, DCM_CONFIG_DIR, DCM_PROFILES_DIR } from "../constants";



export type GithubAuthStatus = Omit<GhAuthStatus, "token">;
export type GithubUserResponse = Endpoints["GET /user"]["response"];
export type GithubUser = GithubUserResponse["data"];


export type ResponseCache<T> = OctokitResponse<T>;

export interface DCMConfig {
    profileRepo: string;
    profile: string;
}

export interface DCMProfilesRepoMeta {
    defaultProfile: string;
}


export interface DCMProfile {
    name: string;
    description: string;
}


const DEFAULT_CONFIG: DCMConfig = {

} as DCMConfig;


const GH_AUTH_STATUS_CACHE_FILE = `${DCM_CACHE_DIR}/gh-auth-status.yml`;
const CONFIG_FILE = `${DCM_CONFIG_DIR}/git.yml`;


const SCOPES_ADDITIONAL = ["gist"];
const SCOPES_REQUIRED = ["read:packages", "read:user", "user:email", "read:org", "repo", "workflow"];
const SCOPES = [...SCOPES_ADDITIONAL, ...SCOPES_REQUIRED];


export class GithubSessionOld {
    private static _instancePromise: Promise<GithubSessionOld>;

    public static get instance(): Promise<GithubSessionOld> {
        if (!this._instancePromise) {
            this._instancePromise = new Promise<GithubSessionOld>(async (resolve, reject) => {
                try {
                    const inst = new GithubSessionOld();
                    await inst._initialize();
                    resolve(inst);
                } catch (e) {
                    reject(e);
                }
            });
        }
        return this._instancePromise;
    }



    public static async ensureGithubAuth() {
        const inst = await this.instance;
        await inst._ensureGithubAuth();



        /*

        const user = await inst._octokit?.users.getAuthenticated();
        if (!inst._config!.name) {
            inst._config!.name = user?.data.name!;
        }

        if (!inst._config!.email) {
            const emails = await inst._octokit?.users.listEmailsForAuthenticatedUser();
            const email = emails?.data.find((e) => e.visibility === null)?.email;
            inst._config!.email = email!;
            await inst._saveConfig();
        }*/
    }

    public static async login() {
        const inst = await this.instance;
        const prompt = await importInquirer();
        const status = await inst.ghAuthStatus;
        if (status) {
            const { confirm } = await prompt.prompt<{ confirm: boolean }>([
                {
                    type: "confirm",
                    name: "confirm",
                    message: "You are already logged in. Do you want to log out and log in again?"
                }
            ]);
            if (!confirm) {
                return;
            }
            await inst._logoutGithubUser();
        }
        await this.ensureGithubAuth();
    }

    public static async setup() {
        await this.ensureGithubAuth();

        const inst = await this.instance;
        const prompt = (await importInquirer()).prompt;
        const chalk = await importChalk();
        const status = await inst.ghAuthStatus;
        const config = inst._config!;

        const { profileRepo } = await prompt([
            {
                type: "input",
                name: "profileRepo",
                message: "Enter the name of the repository where your profiles are stored:",
                default: config.profileRepo || `${status?.username}/dcm-profiles`
            }
        ]);

        console.log(chalk.green(`Using repository '${profileRepo}'`));
        await inst._ensureConfigProfilesRepo(profileRepo);

    }

    private async _ensureConfigProfilesRepo(repoPath: string) {
        const path = `${DCM_PROFILES_DIR}/${repoPath}`;
        if (!existsSync(path)) {
            const [owner, repo] = repoPath.split("/");
            try {
                await this._octokit?.repos.get({ owner, repo });
                await this._cloneConfigProfilesRepo(repoPath);
            } catch (e) {
                const err = e as any;
                if (err.status === 404) {
                    await this._createConfigProfilesRepo(repoPath);
                } else {
                    throw e;
                }
            }
        } else {
            this._syncConfigProfilesRepo(repoPath);
        }
    }

    private async _createConfigProfilesRepo(repoPath: string) {
        const [owner, repo] = repoPath.split("/");
        this._octokit?.repos.createUsingTemplate({
            template_owner: "cpdevtools",
            template_repo: "dcm-profiles-template",
            owner,
            name: repo,
            private: true
        });
        await this._cloneConfigProfilesRepo(repoPath);
        await this._initializeConfigProfilesRepo(repoPath);
    }



    private async _cloneConfigProfilesRepo(repo: string) {
        await rm(`${DCM_PROFILES_DIR}/${repo}`, { recursive: true, force: true });
        await mkdir(`${DCM_PROFILES_DIR}/${repo}`, { recursive: true });
        await exec(`gh repo clone ${repo} ${DCM_PROFILES_DIR}/${repo}`);
    }

    private async _initializeConfigProfilesRepo(repo: string) {
        const prompt = (await importInquirer()).prompt;
        const { profileName, profileDescription } = await prompt([
            {
                type: "input",
                name: "profileName",
                message: "Enter the name of the profile you want to create:",
                default: "default",
                validate: (input: string) => {
                    if (!input) {
                        return "Please enter a name for the profile";
                    }
                    return true;
                }
            },
            {
                type: "input",
                name: "profileDescription",
                message: "Enter a description for the profile:",
                default: "Default profile"
            }
        ]);

        const profilesPath = `${DCM_PROFILES_DIR}/${repo}`;
        const profilePath = `${profilesPath}/profiles/${profileName}`;

        await mkdir(profilePath, { recursive: true });
        await exec(`cp -r ${DCM_PROFILES_DIR}/${repo}/profile-tpl/* ${profilePath}`);

        const profileMeta = await readYamlFile<DCMProfilesRepoMeta>(`${profilesPath}/profiles.yml`);
        profileMeta.defaultProfile = profileName;
        await writeYamlFile(`${profilesPath}/profiles.yml`, profileMeta);

        const profile = await readYamlFile<DCMProfile>(`${profilePath}/profile.yml`);
        profile.name = profileName;
        profile.description = profileDescription;
        await writeYamlFile(`${profilePath}/profile.yml`, profile);

        await exec(`cd ${profilesPath} &&  git add . && git commit -m "Initialized profile '${profileName}'" && git push`);

    }

    private async _syncConfigProfilesRepo(repo: string) {
        const path = `${DCM_PROFILES_DIR}/${repo}`;
        await exec(`cd ${path} && git add . && git commit -m "sync" && git pull && git push`);
    }

    public static async logout() {
        const inst = await this.instance;
        await inst._logoutGithubUser();
        return inst;
    }



    private _responseCache: { [key: string]: ResponseCache<any> } = {};

    private _findInCache(eTag: string) {
        return this._responseCache[this._eTag(eTag)];
    }

    private _setCache(eTag: string, cache: ResponseCache<any>) {
        this._responseCache[this._eTag(eTag)] = cache;
    }

    private _eTag(eTag: string) {
        const normalized = eTag.replace(/"/g, "").replace(/^W\//i, "").trim();
        return normalized;
    }

    private _opts2CacheFile(options: Required<EndpointDefaults>) {
        const key = `${options.method}-${options.url}`;
        const encKey = encodeURIComponent(key);
        const cacheFilePath = `${DCM_CACHE_DIR}/gh-cache_${encKey}.yml`;
        const cacheFile = new CachedFile<ResponseCache<any>>(cacheFilePath, 30);
        return cacheFile;
    }

    private _initializeOctokit(token: string) {
        const octokit = new Octokit({ auth: token });
        octokit.hook.error("request", async (error, options) => {
            if ('status' in error) {
                if (error.status === 304) {
                    const cache = this._findInCache(error.response?.headers.etag!);
                    const expToken = cache.headers["github-authentication-token-expiration"];
                    cache.headers = error.response?.headers!;
                    cache.headers["github-authentication-token-expiration"] ||= expToken;

                    console.info(`Loaded "${options.method}-${options.url}" from cache using etag: '${this._eTag(error.response?.headers.etag!)}'`);
                    cache.headers["x-dcm-cache"] = "etag";
                    cache.status = 200;

                    const cacheFile = this._opts2CacheFile(options);
                    cacheFile.write(cache);
                    return cache;
                }
            }
            throw error;
        });


        octokit.hook.wrap("request", async (request, options) => {
            const cacheFile = this._opts2CacheFile(options);

            if (!await cacheFile.isExpired()) {
                const cached = await cacheFile.read();
                console.info(`Loaded "${cached.url}" from cache before request`);
                this._setCache(cached.headers.etag!, cached);
                cached.headers["x-dcm-cache"] = "timed";
                cached.status = 200;
                return cached;
            }

            if (cacheFile.exists()) {
                const expiredCache = await cacheFile.read(false);
                this._setCache(expiredCache.headers.etag!, expiredCache);
                options.headers["if-none-match"] = `W/"${this._eTag(expiredCache.headers.etag!)}"`;
            }

            const response = await request(options);
            // console.log(response.headers);

            if (response.headers["github-authentication-token-expiration"]) {

                const exp = parseJSON(response.headers["github-authentication-token-expiration"] as string);
                if (isValid(exp)) {
                    // console.log(exp);
                    const diff = differenceInHours(exp, new Date());
                    // console.log(diff);
                    // console.log(formatDistanceToNow(exp));
                    if (diff < 720) {
                        console.warn(`Token is about to expire in ${formatDistanceToNow(exp)}. run 'dcm login' to refresh token`);
                    }
                }
            }

            if (response.status === 200 && !response.headers["x-dcm-cache"]) {
                console.info(`Writing "${response.url}" to cache after request`);
                await cacheFile.write(response);
                this._setCache(response.headers.etag!, response);
            }
            return response;
        });

        this._octokit = octokit;
    }

    private _ghAuthStatusCacheFile = new CachedFile<GithubAuthStatus>(GH_AUTH_STATUS_CACHE_FILE, 5);
    private _ghAuthStatus?: Promise<GithubAuthStatus | undefined>;
    private _octokit?: Octokit;
    private __token?: string;



    private async _loadGhAuthStatus(): Promise<GithubAuthStatus | undefined> {
        if (!await this._ghAuthStatusCacheFile.isExpired()) {
            return await this._ghAuthStatusCacheFile.read();
        }
        try {
            const authData = await githubAuthStatus(this._env());
            this._initializeOctokit(authData.token);
            let data = {
                ...authData,
                token: undefined
            };
            delete data.token;
            await this._ghAuthStatusCacheFile.write(data);
            return data;
        } catch (e) {
            await this._ghAuthStatusCacheFile.delete();
            return undefined;
        }
    }

    private _getGhAuthStatus(): Promise<GithubAuthStatus | undefined> {
        if (!this._ghAuthStatus) {
            this._ghAuthStatus = this._loadGhAuthStatus();
        }
        return this._ghAuthStatus!;
    }

    public get ghAuthStatus(): Promise<GithubAuthStatus | undefined> {
        return this._getGhAuthStatus();
    }


    private _config?: DCMConfig;

    private get _configExists() {
        return existsSync(CONFIG_FILE);
    }

    private async _loadConfig() {
        if (this._configExists) {
            this._config = await readYamlFile<DCMConfig>(CONFIG_FILE);

        } else {
            this._config = undefined;
        }
    }

    private async _saveConfig() {
        if (this._config) {
            await writeYamlFile(CONFIG_FILE, this._config);
        }
    }

    private constructor() { }


    private async _initialize() {
        await this._loadConfig();
    }

    private async _validateGithubUserScopes(scopes: string[]) {
        return SCOPES_REQUIRED.filter((scope) => !scopes.includes(scope));
    }

    private _env() {
        const env = { ...process.env };
        delete env.GITHUB_TOKEN;
        delete env.GH_TOKEN;
        return env;
    }

    private async _logoutGithubUser() {
        await exec(`gh auth logout -h github.com`, { env: this._env() });
        await this._ghAuthStatusCacheFile.delete();

        // this._config!.name = '';
        // this._config!.email = '';
        // await this._saveConfig();

        this._ghAuthStatus = undefined;
        this._octokit = undefined;
        this.__token = undefined;
    }

    private async _loginGithubUser(authMethod?: "browser" | "token") {
        const prompt = (await importInquirer()).prompt;
        const chalk = await importChalk();

        if (!authMethod) {
            const { am } = await prompt([
                {
                    type: "list",
                    name: "am",
                    message: "Select authentication method",
                    choices: [
                        {
                            name: "Authenticate with Browser",
                            value: "browser"
                        },
                        {
                            name: "Authenticate with Token",
                            value: "token"
                        }
                    ],
                    default: "browser"
                }
            ]);
            authMethod = am;
        }

        const status = await this.ghAuthStatus;
        if (status) {
            await this._logoutGithubUser();
        }

        if (authMethod === "token") {

            console.info(`[${chalk.yellowBright('Tip')}] You can generate a Personal Access Token here ${chalk.blueBright('https://github.com/settings/tokens')}\n`);
            console.info(`Required scopes:\n   - ${SCOPES_REQUIRED.join("\n   - ")}\n`);
            console.info(`Optional scopes:\n   - ${SCOPES_ADDITIONAL.join("\n   - ")}\n`);

            const { token } = await prompt([
                {
                    type: "input",
                    name: "token",
                    message: "Enter github token"
                }
            ]);
            const success = !(await exec(`echo "${token}" | gh auth login -h github.com -p https --with-token`, { env: this._env() }));
            await this._ghAuthStatusCacheFile.delete();
            this._ghAuthStatus = undefined;
            return success;
        } else {
            const success = !(await exec(`gh auth login -h github.com -p https -s ${SCOPES.join(",")} -w`, { env: this._env() }));
            await this._ghAuthStatusCacheFile.delete();
            this._ghAuthStatus = undefined;
            return success;
        }
    }

    private async _refreshGitubAuth(missingScopes?: string[]) {
        let cmd = `gh auth refresh --insecure-storage -h github.com`;
        if (missingScopes?.length) {
            cmd += ` -s ${missingScopes.join(",")}`;
        }

        const success = !(await exec(cmd));
        await this._ghAuthStatusCacheFile.delete();
        this._ghAuthStatus = undefined;
        return success;
    }

    private get _token() {
        return this.__token;
    }

    private get _isOAuth() {
        return this._token?.startsWith("gho_");
    }

    private async _ensureGithubAuth() {
        console.info(`Validating github user status:`);

        let status = await this.ghAuthStatus;
        while (!status) {
            const success = await this._loginGithubUser();
            if (success) {
                status = await this.ghAuthStatus;
            }
        }

        let missingScopes = await this._validateGithubUserScopes(status.scopes);
        while (missingScopes.length) {
            console.info(``);
            console.info(`You are missing the following scopes:\n - ${missingScopes.join("\n - ")}`);
            let success = false;
            if (this._isOAuth) {
                success = await this._refreshGitubAuth(missingScopes);
            } else {
                success = await this._loginGithubUser();
            }

            if (success) {
                status = await this.ghAuthStatus;
                missingScopes = await this._validateGithubUserScopes(status!.scopes);
            }
        }
    }

    public get profileRepository() {
        return this._config?.profileRepo;
    }

    public get activeProfile() {
        return this._config?.profile;
    }

    /*
    
        private _githubUserData?: Promise<GithubUserStatus | undefined>;
    
        private async _loadGhUserData(): Promise<GithubUserStatus | undefined> {
            const file = new CachedFile(GH_STATUS_CACHE_FILE);
    
            if (!await file.isExpired()) {
                return await file.read();
            }
            const authData = await githubAuthStatus();
            if (authData) {
                let data = {
                    ...authData,
                    token: undefined
                };
                delete data.token;
                await file.write(data);
                return data;
            }
            return undefined;
        }
    
        public get githubUserData(): Promise<GithubUserStatus | undefined> {
            if (!this._githubUserStatusPromise) {
                this._githubUserStatusPromise = new Promise<GithubUserStatus | undefined>(async (resolve, reject) => {
                    try {
                        const status = await this._loadGhStatus();
                        resolve(status);
                    } catch (e) {
                        reject(e);
                    }
    
                });
            }
            return this._githubUserStatusPromise;
        }
    
    */



}